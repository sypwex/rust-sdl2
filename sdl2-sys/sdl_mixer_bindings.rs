/* automatically generated by rust-bindgen */

use crate::*;
use core::ffi::c_int;
use core::ffi::c_void;
use core::ffi::c_char;
use core::ffi::c_long;
use core::ffi::c_uint;
use core::ffi::c_ushort;
use core::ffi::c_short;
use core::ffi::c_uchar;

pub const MIX_MAJOR_VERSION: u32 = 2;
pub const MIX_MINOR_VERSION: u32 = 0;
pub const MIX_PATCHLEVEL: u32 = 4;
pub const MIX_CHANNELS: u32 = 8;
pub const MIX_DEFAULT_FREQUENCY: u32 = 22050;
pub const MIX_DEFAULT_FORMAT: u32 = 32784;
pub const MIX_DEFAULT_CHANNELS: u32 = 2;
pub const MIX_MAX_VOLUME: u32 = 128;
pub const MIX_CHANNEL_POST: i32 = -2;
pub const MIX_EFFECTSMAXSPEED: &'static [u8; 20usize] = b"MIX_EFFECTSMAXSPEED\0";
pub type __uint8_t = c_uchar;
pub type __int16_t = c_short;
pub type __uint16_t = c_ushort;
pub type __uint32_t = c_uint;
pub type __int64_t = c_long;
pub type __off_t = c_long;
pub type __off64_t = c_long;
pub type Uint8 = u8;
pub type Sint16 = i16;
pub type Uint16 = u16;
pub type Uint32 = u32;
pub type Sint64 = i64;
extern "C" {
    pub fn Mix_Linked_Version() -> *const SDL_version;
}
pub const MIX_InitFlags_MIX_INIT_FLAC: MIX_InitFlags = 1;
pub const MIX_InitFlags_MIX_INIT_MOD: MIX_InitFlags = 2;
pub const MIX_InitFlags_MIX_INIT_MP3: MIX_InitFlags = 8;
pub const MIX_InitFlags_MIX_INIT_OGG: MIX_InitFlags = 16;
pub const MIX_InitFlags_MIX_INIT_MID: MIX_InitFlags = 32;
pub const MIX_InitFlags_MIX_INIT_OPUS: MIX_InitFlags = 64;
pub type MIX_InitFlags = u32;
extern "C" {
    pub fn Mix_Init(flags: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_Quit();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Mix_Chunk {
    pub allocated: c_int,
    pub abuf: *mut Uint8,
    pub alen: Uint32,
    pub volume: Uint8,
}
#[test]
fn bindgen_test_layout_Mix_Chunk() {
    assert_eq!(
        ::core::mem::size_of::<Mix_Chunk>(),
        24usize,
        concat!("Size of: ", stringify!(Mix_Chunk))
    );
    assert_eq!(
        ::core::mem::align_of::<Mix_Chunk>(),
        8usize,
        concat!("Alignment of ", stringify!(Mix_Chunk))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mix_Chunk>())).allocated as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Mix_Chunk),
            "::",
            stringify!(allocated)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mix_Chunk>())).abuf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Mix_Chunk),
            "::",
            stringify!(abuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mix_Chunk>())).alen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Mix_Chunk),
            "::",
            stringify!(alen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mix_Chunk>())).volume as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Mix_Chunk),
            "::",
            stringify!(volume)
        )
    );
}
pub const Mix_Fading_MIX_NO_FADING: Mix_Fading = 0;
pub const Mix_Fading_MIX_FADING_OUT: Mix_Fading = 1;
pub const Mix_Fading_MIX_FADING_IN: Mix_Fading = 2;
pub type Mix_Fading = u32;
pub const Mix_MusicType_MUS_NONE: Mix_MusicType = 0;
pub const Mix_MusicType_MUS_CMD: Mix_MusicType = 1;
pub const Mix_MusicType_MUS_WAV: Mix_MusicType = 2;
pub const Mix_MusicType_MUS_MOD: Mix_MusicType = 3;
pub const Mix_MusicType_MUS_MID: Mix_MusicType = 4;
pub const Mix_MusicType_MUS_OGG: Mix_MusicType = 5;
pub const Mix_MusicType_MUS_MP3: Mix_MusicType = 6;
pub const Mix_MusicType_MUS_MP3_MAD_UNUSED: Mix_MusicType = 7;
pub const Mix_MusicType_MUS_FLAC: Mix_MusicType = 8;
pub const Mix_MusicType_MUS_MODPLUG_UNUSED: Mix_MusicType = 9;
pub const Mix_MusicType_MUS_OPUS: Mix_MusicType = 10;
pub type Mix_MusicType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mix_Music {
    _unused: [u8; 0],
}
pub type Mix_Music = _Mix_Music;
extern "C" {
    pub fn Mix_OpenAudio(
        frequency: c_int,
        format: Uint16,
        channels: c_int,
        chunksize: c_int,
    ) -> c_int;
}
extern "C" {
    pub fn Mix_OpenAudioDevice(
        frequency: c_int,
        format: Uint16,
        channels: c_int,
        chunksize: c_int,
        device: *const c_char,
        allowed_changes: c_int,
    ) -> c_int;
}
extern "C" {
    pub fn Mix_AllocateChannels(numchans: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_QuerySpec(
        frequency: *mut c_int,
        format: *mut Uint16,
        channels: *mut c_int,
    ) -> c_int;
}
extern "C" {
    pub fn Mix_LoadWAV_RW(src: *mut SDL_RWops, freesrc: c_int) -> *mut Mix_Chunk;
}
extern "C" {
    pub fn Mix_LoadMUS(file: *const c_char) -> *mut Mix_Music;
}
extern "C" {
    pub fn Mix_LoadMUS_RW(src: *mut SDL_RWops, freesrc: c_int) -> *mut Mix_Music;
}
extern "C" {
    pub fn Mix_LoadMUSType_RW(
        src: *mut SDL_RWops,
        type_: Mix_MusicType,
        freesrc: c_int,
    ) -> *mut Mix_Music;
}
extern "C" {
    pub fn Mix_QuickLoad_WAV(mem: *mut Uint8) -> *mut Mix_Chunk;
}
extern "C" {
    pub fn Mix_QuickLoad_RAW(mem: *mut Uint8, len: Uint32) -> *mut Mix_Chunk;
}
extern "C" {
    pub fn Mix_FreeChunk(chunk: *mut Mix_Chunk);
}
extern "C" {
    pub fn Mix_FreeMusic(music: *mut Mix_Music);
}
extern "C" {
    pub fn Mix_GetNumChunkDecoders() -> c_int;
}
extern "C" {
    pub fn Mix_GetChunkDecoder(index: c_int) -> *const c_char;
}
extern "C" {
    pub fn Mix_HasChunkDecoder(name: *const c_char) -> SDL_bool;
}
extern "C" {
    pub fn Mix_GetNumMusicDecoders() -> c_int;
}
extern "C" {
    pub fn Mix_GetMusicDecoder(index: c_int) -> *const c_char;
}
extern "C" {
    pub fn Mix_HasMusicDecoder(name: *const c_char) -> SDL_bool;
}
extern "C" {
    pub fn Mix_GetMusicType(music: *const Mix_Music) -> Mix_MusicType;
}
extern "C" {
    pub fn Mix_SetPostMix(
        mix_func: ::core::option::Option<
            unsafe extern "C" fn(udata: *mut c_void, stream: *mut Uint8, len: c_int),
        >,
        arg: *mut c_void,
    );
}
extern "C" {
    pub fn Mix_HookMusic(
        mix_func: ::core::option::Option<
            unsafe extern "C" fn(udata: *mut c_void, stream: *mut Uint8, len: c_int),
        >,
        arg: *mut c_void,
    );
}
extern "C" {
    pub fn Mix_HookMusicFinished(music_finished: ::core::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn Mix_GetMusicHookData() -> *mut c_void;
}
extern "C" {
    pub fn Mix_ChannelFinished(
        channel_finished: ::core::option::Option<unsafe extern "C" fn(channel: c_int)>,
    );
}
pub type Mix_EffectFunc_t = ::core::option::Option<
    unsafe extern "C" fn(
        chan: c_int,
        stream: *mut c_void,
        len: c_int,
        udata: *mut c_void,
    ),
>;
pub type Mix_EffectDone_t =
    ::core::option::Option<unsafe extern "C" fn(chan: c_int, udata: *mut c_void)>;
extern "C" {
    pub fn Mix_RegisterEffect(
        chan: c_int,
        f: Mix_EffectFunc_t,
        d: Mix_EffectDone_t,
        arg: *mut c_void,
    ) -> c_int;
}
extern "C" {
    pub fn Mix_UnregisterEffect(channel: c_int, f: Mix_EffectFunc_t) -> c_int;
}
extern "C" {
    pub fn Mix_UnregisterAllEffects(channel: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_SetPanning(channel: c_int, left: Uint8, right: Uint8) -> c_int;
}
extern "C" {
    pub fn Mix_SetPosition(channel: c_int, angle: Sint16, distance: Uint8) -> c_int;
}
extern "C" {
    pub fn Mix_SetDistance(channel: c_int, distance: Uint8) -> c_int;
}
extern "C" {
    pub fn Mix_SetReverseStereo(channel: c_int, flip: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_ReserveChannels(num: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_GroupChannel(which: c_int, tag: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_GroupChannels(from: c_int, to: c_int, tag: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_GroupAvailable(tag: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_GroupCount(tag: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_GroupOldest(tag: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_GroupNewer(tag: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_PlayChannelTimed(
        channel: c_int,
        chunk: *mut Mix_Chunk,
        loops: c_int,
        ticks: c_int,
    ) -> c_int;
}
extern "C" {
    pub fn Mix_PlayMusic(music: *mut Mix_Music, loops: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_FadeInMusic(
        music: *mut Mix_Music,
        loops: c_int,
        ms: c_int,
    ) -> c_int;
}
extern "C" {
    pub fn Mix_FadeInMusicPos(
        music: *mut Mix_Music,
        loops: c_int,
        ms: c_int,
        position: f64,
    ) -> c_int;
}
extern "C" {
    pub fn Mix_FadeInChannelTimed(
        channel: c_int,
        chunk: *mut Mix_Chunk,
        loops: c_int,
        ms: c_int,
        ticks: c_int,
    ) -> c_int;
}
extern "C" {
    pub fn Mix_Volume(channel: c_int, volume: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_VolumeChunk(chunk: *mut Mix_Chunk, volume: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_VolumeMusic(volume: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_HaltChannel(channel: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_HaltGroup(tag: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_HaltMusic() -> c_int;
}
extern "C" {
    pub fn Mix_ExpireChannel(channel: c_int, ticks: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_FadeOutChannel(which: c_int, ms: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_FadeOutGroup(tag: c_int, ms: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_FadeOutMusic(ms: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_FadingMusic() -> Mix_Fading;
}
extern "C" {
    pub fn Mix_FadingChannel(which: c_int) -> Mix_Fading;
}
extern "C" {
    pub fn Mix_Pause(channel: c_int);
}
extern "C" {
    pub fn Mix_Resume(channel: c_int);
}
extern "C" {
    pub fn Mix_Paused(channel: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_PauseMusic();
}
extern "C" {
    pub fn Mix_ResumeMusic();
}
extern "C" {
    pub fn Mix_RewindMusic();
}
extern "C" {
    pub fn Mix_PausedMusic() -> c_int;
}
extern "C" {
    pub fn Mix_SetMusicPosition(position: f64) -> c_int;
}
extern "C" {
    pub fn Mix_Playing(channel: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_PlayingMusic() -> c_int;
}
extern "C" {
    pub fn Mix_SetMusicCMD(command: *const c_char) -> c_int;
}
extern "C" {
    pub fn Mix_SetSynchroValue(value: c_int) -> c_int;
}
extern "C" {
    pub fn Mix_GetSynchroValue() -> c_int;
}
extern "C" {
    pub fn Mix_SetSoundFonts(paths: *const c_char) -> c_int;
}
extern "C" {
    pub fn Mix_GetSoundFonts() -> *const c_char;
}
extern "C" {
    pub fn Mix_EachSoundFont(
        function: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const c_char, arg2: *mut c_void) -> c_int,
        >,
        data: *mut c_void,
    ) -> c_int;
}
extern "C" {
    pub fn Mix_GetChunk(channel: c_int) -> *mut Mix_Chunk;
}
extern "C" {
    pub fn Mix_CloseAudio();
}
